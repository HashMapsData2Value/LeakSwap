#pragma version 10

smart_contracts.leak_swap.contract.LeakSwap.approval_program:
    intcblock 0 1
    bytecblock 0x616c6963655f616c676f5f61646472 0x74305f74696d657374616d70 0x78696e5f616c676f5f61646472 0x74315f74696d657374616d70 0x616c695f7265616479 "data_to_sign"
    txn ApplicationID
    bnz main_after_if_else@2
    callsub __init__

main_after_if_else@2:
    callsub __puya_arc4_router__
    return


// smart_contracts.leak_swap.contract.LeakSwap.__init__() -> void:
__init__:
    // smart_contracts/leak_swap/contract.py:19
    // def __init__(self) -> None:
    proto 0 0
    // smart_contracts/leak_swap/contract.py:20
    // self.ali_algo_addr = GlobalState(arc4.Address(), key=b"alice_algo_addr")
    bytec_0 // 0x616c6963655f616c676f5f61646472
    global ZeroAddress
    app_global_put
    // smart_contracts/leak_swap/contract.py:23
    // self.xin_algo_addr = GlobalState(arc4.Address(), key=b"xin_algo_addr")
    bytec_2 // 0x78696e5f616c676f5f61646472
    global ZeroAddress
    app_global_put
    // smart_contracts/leak_swap/contract.py:31
    // self.data_to_sign = Global.current_application_address.bytes
    bytec 5 // "data_to_sign"
    global CurrentApplicationAddress
    app_global_put
    retsub


// smart_contracts.leak_swap.contract.LeakSwap.__puya_arc4_router__() -> uint64:
__puya_arc4_router__:
    // smart_contracts/leak_swap/contract.py:16-18
    // # Ali <-- Algo/ASA asset holder, wants to swap for foreign asset
    // # Xin <-- Foreign asset holder, wants to swap for Algo/ASA asset
    // class LeakSwap(ARC4Contract):
    proto 0 1
    txn NumAppArgs
    bz __puya_arc4_router___after_if_else@11
    pushbytess 0x02bece11 0x4c5c61ba 0xb4ed4f93 0x1f7a4a13 0x736ea3d4 0x7bda2dfa // method "hello(string)string", method "create()void", method "set_ready()void", method "leaky_refund(byte[])void", method "leaky_claim(byte[])void", method "punish_refund()void"
    txna ApplicationArgs 0
    match __puya_arc4_router___hello_route@2 __puya_arc4_router___create_route@3 __puya_arc4_router___set_ready_route@4 __puya_arc4_router___leaky_refund_route@5 __puya_arc4_router___leaky_claim_route@6 __puya_arc4_router___punish_refund_route@7
    intc_0 // 0
    retsub

__puya_arc4_router___hello_route@2:
    // smart_contracts/leak_swap/contract.py:33
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/leak_swap/contract.py:16-18
    // # Ali <-- Algo/ASA asset holder, wants to swap for foreign asset
    // # Xin <-- Foreign asset holder, wants to swap for Algo/ASA asset
    // class LeakSwap(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/leak_swap/contract.py:33
    // @arc4.abimethod()
    callsub hello
    dup
    len
    itob
    extract 6 2
    swap
    concat
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    retsub

__puya_arc4_router___create_route@3:
    // smart_contracts/leak_swap/contract.py:37
    // @arc4.abimethod(create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    callsub create
    intc_1 // 1
    retsub

__puya_arc4_router___set_ready_route@4:
    // smart_contracts/leak_swap/contract.py:95
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub set_ready
    intc_1 // 1
    retsub

__puya_arc4_router___leaky_refund_route@5:
    // smart_contracts/leak_swap/contract.py:104
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/leak_swap/contract.py:16-18
    // # Ali <-- Algo/ASA asset holder, wants to swap for foreign asset
    // # Xin <-- Foreign asset holder, wants to swap for Algo/ASA asset
    // class LeakSwap(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/leak_swap/contract.py:104
    // @arc4.abimethod()
    callsub leaky_refund
    intc_1 // 1
    retsub

__puya_arc4_router___leaky_claim_route@6:
    // smart_contracts/leak_swap/contract.py:124
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/leak_swap/contract.py:16-18
    // # Ali <-- Algo/ASA asset holder, wants to swap for foreign asset
    // # Xin <-- Foreign asset holder, wants to swap for Algo/ASA asset
    // class LeakSwap(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/leak_swap/contract.py:124
    // @arc4.abimethod()
    callsub leaky_claim
    intc_1 // 1
    retsub

__puya_arc4_router___punish_refund_route@7:
    // smart_contracts/leak_swap/contract.py:147
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub punish_refund
    intc_1 // 1
    retsub

__puya_arc4_router___after_if_else@11:
    // smart_contracts/leak_swap/contract.py:16-18
    // # Ali <-- Algo/ASA asset holder, wants to swap for foreign asset
    // # Xin <-- Foreign asset holder, wants to swap for Algo/ASA asset
    // class LeakSwap(ARC4Contract):
    intc_0 // 0
    retsub


// smart_contracts.leak_swap.contract.LeakSwap.hello(name: bytes) -> bytes:
hello:
    // smart_contracts/leak_swap/contract.py:33-34
    // @arc4.abimethod()
    // def hello(self, name: String) -> String:
    proto 1 1
    // smart_contracts/leak_swap/contract.py:35
    // return "Hello, " + name
    pushbytes "Hello, "
    frame_dig -1
    concat
    retsub


// smart_contracts.leak_swap.contract.LeakSwap.create() -> void:
create:
    // smart_contracts/leak_swap/contract.py:37-38
    // @arc4.abimethod(create="require")
    // def create(self) -> None:
    proto 0 0
    // smart_contracts/leak_swap/contract.py:42
    // self.ali_algo_addr.value = arc4.Address(Txn.sender)
    bytec_0 // 0x616c6963655f616c676f5f61646472
    txn Sender
    app_global_put
    // smart_contracts/leak_swap/contract.py:44
    // assert self.t0.value > Global.latest_timestamp
    intc_0 // 0
    bytec_1 // 0x74305f74696d657374616d70
    app_global_get_ex
    assert // check self.t0 exists
    global LatestTimestamp
    >
    assert
    // smart_contracts/leak_swap/contract.py:45
    // assert self.t1.value > self.t0.value
    intc_0 // 0
    bytec_3 // 0x74315f74696d657374616d70
    app_global_get_ex
    assert // check self.t1 exists
    intc_0 // 0
    bytec_1 // 0x74305f74696d657374616d70
    app_global_get_ex
    assert // check self.t0 exists
    >
    assert
    retsub


// smart_contracts.leak_swap.contract.LeakSwap.set_ready() -> void:
set_ready:
    // smart_contracts/leak_swap/contract.py:95-96
    // @arc4.abimethod()
    // def set_ready(self) -> None:
    proto 0 0
    // smart_contracts/leak_swap/contract.py:101
    // assert Txn.sender == self.ali_algo_addr.value.native
    txn Sender
    intc_0 // 0
    bytec_0 // 0x616c6963655f616c676f5f61646472
    app_global_get_ex
    assert // check self.ali_algo_addr exists
    ==
    assert
    // smart_contracts/leak_swap/contract.py:102
    // self.ali_ready.value = True
    bytec 4 // 0x616c695f7265616479
    intc_1 // 1
    app_global_put
    retsub


// smart_contracts.leak_swap.contract.LeakSwap.leaky_refund(signature: bytes) -> void:
leaky_refund:
    // smart_contracts/leak_swap/contract.py:104-105
    // @arc4.abimethod()
    // def leaky_refund(self, signature: Bytes) -> None:
    proto 1 0
    // smart_contracts/leak_swap/contract.py:111-112
    // # Check called by Ali
    // assert Txn.sender == self.ali_algo_addr.value.native
    txn Sender
    intc_0 // 0
    bytec_0 // 0x616c6963655f616c676f5f61646472
    app_global_get_ex
    assert // check self.ali_algo_addr exists
    ==
    assert
    // smart_contracts/leak_swap/contract.py:114-115
    // # Check contract has not passed t0/ready
    // assert Global.latest_timestamp <= self.t0.value
    global LatestTimestamp
    intc_0 // 0
    bytec_1 // 0x74305f74696d657374616d70
    app_global_get_ex
    assert // check self.t0 exists
    <=
    assert
    // smart_contracts/leak_swap/contract.py:116
    // assert self.ali_ready.value == False
    intc_0 // 0
    bytec 4 // 0x616c695f7265616479
    app_global_get_ex
    assert // check self.ali_ready exists
    !
    assert
    // smart_contracts/leak_swap/contract.py:118-119
    // # Force Ali to leak xternal secret key
    // self.leaky_verify_ed25519(signature, self.ali_xternal_pk.value)
    intc_0 // 0
    pushbytes 0x616c6963655f787465726e616c5f706b
    app_global_get_ex
    assert // check self.ali_xternal_pk exists
    frame_dig -1
    swap
    callsub leaky_verify_ed25519
    // smart_contracts/leak_swap/contract.py:121-122
    // # Return Ali's funds
    // self.disburse_funds(self.ali_algo_addr.value)
    intc_0 // 0
    bytec_0 // 0x616c6963655f616c676f5f61646472
    app_global_get_ex
    assert // check self.ali_algo_addr exists
    callsub disburse_funds
    retsub


// smart_contracts.leak_swap.contract.LeakSwap.leaky_verify_ed25519(signature: bytes, xternal_pk: bytes) -> void:
leaky_verify_ed25519:
    // smart_contracts/leak_swap/contract.py:78-79
    // @subroutine
    // def leaky_verify_ed25519(self, signature: Bytes, xternal_pk: Bytes) -> None:
    proto 2 0
    // smart_contracts/leak_swap/contract.py:85
    // assert op.extract(signature, 0, 32) == Bytes(b"Xfffffffffffffffffffffffffffffff")
    frame_dig -2
    extract 0 32
    pushbytes 0x5866666666666666666666666666666666666666666666666666666666666666
    ==
    assert
    // smart_contracts/leak_swap/contract.py:86
    // assert op.ed25519verify_bare(self.data_to_sign, signature, xternal_pk)
    intc_0 // 0
    bytec 5 // "data_to_sign"
    app_global_get_ex
    assert // check self.data_to_sign exists
    frame_dig -2
    frame_dig -1
    ed25519verify_bare
    assert
    retsub


// smart_contracts.leak_swap.contract.LeakSwap.disburse_funds(recipient: bytes) -> void:
disburse_funds:
    // smart_contracts/leak_swap/contract.py:54-55
    // @subroutine
    // def disburse_funds(self, recipient: arc4.Address) -> None:
    proto 1 0
    // smart_contracts/leak_swap/contract.py:59-63
    // itxn.Payment(
    //     receiver=recipient.native,
    //     close_remainder_to=recipient.native,
    //     fee=0,
    // ).submit()
    itxn_begin
    frame_dig -1
    itxn_field CloseRemainderTo
    frame_dig -1
    itxn_field Receiver
    // smart_contracts/leak_swap/contract.py:59
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/leak_swap/contract.py:62
    // fee=0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/leak_swap/contract.py:59-63
    // itxn.Payment(
    //     receiver=recipient.native,
    //     close_remainder_to=recipient.native,
    //     fee=0,
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.leak_swap.contract.LeakSwap.leaky_claim(signature: bytes) -> void:
leaky_claim:
    // smart_contracts/leak_swap/contract.py:124-125
    // @arc4.abimethod()
    // def leaky_claim(self, signature: Bytes) -> None:
    proto 1 0
    // smart_contracts/leak_swap/contract.py:131-132
    // # Check called by Xin
    // assert Txn.sender == self.xin_algo_addr.value.native
    txn Sender
    intc_0 // 0
    bytec_2 // 0x78696e5f616c676f5f61646472
    app_global_get_ex
    assert // check self.xin_algo_addr exists
    ==
    assert
    // smart_contracts/leak_swap/contract.py:136
    // Global.latest_timestamp > self.t0.value or self.ali_ready.value == True
    global LatestTimestamp
    intc_0 // 0
    bytec_1 // 0x74305f74696d657374616d70
    app_global_get_ex
    assert // check self.t0 exists
    >
    bnz leaky_claim_bool_true@2
    intc_0 // 0
    bytec 4 // 0x616c695f7265616479
    app_global_get_ex
    assert // check self.ali_ready exists
    intc_1 // 1
    ==
    bz leaky_claim_bool_false@3

leaky_claim_bool_true@2:
    intc_1 // 1
    b leaky_claim_bool_merge@4

leaky_claim_bool_false@3:
    intc_0 // 0

leaky_claim_bool_merge@4:
    // smart_contracts/leak_swap/contract.py:134-137
    // # Check contract has passed t0/ready
    // assert (
    //     Global.latest_timestamp > self.t0.value or self.ali_ready.value == True
    // )
    assert
    // smart_contracts/leak_swap/contract.py:138-139
    // # Check contract has not passed t1
    // assert Global.latest_timestamp <= self.t1.value
    global LatestTimestamp
    intc_0 // 0
    bytec_3 // 0x74315f74696d657374616d70
    app_global_get_ex
    assert // check self.t1 exists
    <=
    assert
    // smart_contracts/leak_swap/contract.py:141-142
    // # Force Xin to leak xternal secret key
    // self.leaky_verify_ed25519(signature, self.xin_xternal_pk.value)
    intc_0 // 0
    pushbytes 0x78696e5f787465726e616c5f706b
    app_global_get_ex
    assert // check self.xin_xternal_pk exists
    frame_dig -1
    swap
    callsub leaky_verify_ed25519
    // smart_contracts/leak_swap/contract.py:144-145
    // # Disburse funds to Xin
    // self.disburse_funds(self.xin_algo_addr.value)
    intc_0 // 0
    bytec_2 // 0x78696e5f616c676f5f61646472
    app_global_get_ex
    assert // check self.xin_algo_addr exists
    callsub disburse_funds
    retsub


// smart_contracts.leak_swap.contract.LeakSwap.punish_refund() -> void:
punish_refund:
    // smart_contracts/leak_swap/contract.py:147-148
    // @arc4.abimethod()
    // def punish_refund(self) -> None:
    proto 0 0
    // smart_contracts/leak_swap/contract.py:149-150
    // # Check called by Ali, in case she wants to punish Xin
    // assert Txn.sender == self.ali_algo_addr.value.native
    txn Sender
    intc_0 // 0
    bytec_0 // 0x616c6963655f616c676f5f61646472
    app_global_get_ex
    assert // check self.ali_algo_addr exists
    ==
    assert
    // smart_contracts/leak_swap/contract.py:152-153
    // # Check contract has passed t1
    // assert Global.latest_timestamp > self.t1.value
    global LatestTimestamp
    intc_0 // 0
    bytec_3 // 0x74315f74696d657374616d70
    app_global_get_ex
    assert // check self.t1 exists
    >
    assert
    // smart_contracts/leak_swap/contract.py:155-156
    // # Return Ali's funds
    // self.disburse_funds(self.ali_algo_addr.value)
    intc_0 // 0
    bytec_0 // 0x616c6963655f616c676f5f61646472
    app_global_get_ex
    assert // check self.ali_algo_addr exists
    callsub disburse_funds
    retsub
