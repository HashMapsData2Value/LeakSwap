#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1
    bytecblock "aliAlgoAddr" "aliReady" "t0" "t1" "xinAlgoAddr" "aliXternalPK" "xinXternalPK" 0x068101
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/leak_swap/contract.algo.ts:16
    // public aliReady = GlobalState({ initialValue: false })
    bytec_1 // "aliReady"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/leak_swap/contract.algo.ts:5
    // export class LeakSwap extends Contract {
    txn NumAppArgs
    bz main_after_if_else@15
    pushbytess 0xadeb06dd 0x21b51b08 0x180425f6 0x13f22628 0x9ee84c01 0xdda88be3 0x084e7c58 // method "createApplication(byte[],account,byte[],uint64,uint64)void", method "verifySignature(byte[],byte[])void", method "setReady()void", method "getContractState()uint64", method "leakyRefund(byte[])void", method "leakyClaim(byte[])void", method "punishRefund()void"
    txna ApplicationArgs 0
    match main_createApplication_route@5 main_verifySignature_route@6 main_setReady_route@7 main_getContractState_route@8 main_leakyRefund_route@9 main_leakyClaim_route@10 main_punishRefund_route@11

main_after_if_else@15:
    // smart_contracts/leak_swap/contract.algo.ts:5
    // export class LeakSwap extends Contract {
    intc_0 // 0
    return

main_punishRefund_route@11:
    // smart_contracts/leak_swap/contract.algo.ts:140
    // public punishRefund(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub punishRefund
    intc_1 // 1
    return

main_leakyClaim_route@10:
    // smart_contracts/leak_swap/contract.algo.ts:123
    // public leakyClaim(signature: bytes): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/leak_swap/contract.algo.ts:5
    // export class LeakSwap extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/leak_swap/contract.algo.ts:123
    // public leakyClaim(signature: bytes): void {
    callsub leakyClaim
    intc_1 // 1
    return

main_leakyRefund_route@9:
    // smart_contracts/leak_swap/contract.algo.ts:107
    // public leakyRefund(signature: bytes): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/leak_swap/contract.algo.ts:5
    // export class LeakSwap extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/leak_swap/contract.algo.ts:107
    // public leakyRefund(signature: bytes): void {
    callsub leakyRefund
    intc_1 // 1
    return

main_getContractState_route@8:
    // smart_contracts/leak_swap/contract.algo.ts:89
    // public getContractState(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getContractState
    itob
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_setReady_route@7:
    // smart_contracts/leak_swap/contract.algo.ts:80
    // public setReady(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub setReady
    intc_1 // 1
    return

main_verifySignature_route@6:
    // smart_contracts/leak_swap/contract.algo.ts:56
    // public verifySignature(signature: bytes, xternalPK: bytes): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/leak_swap/contract.algo.ts:5
    // export class LeakSwap extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/leak_swap/contract.algo.ts:56
    // public verifySignature(signature: bytes, xternalPK: bytes): void {
    callsub verifySignature
    intc_1 // 1
    return

main_createApplication_route@5:
    // smart_contracts/leak_swap/contract.algo.ts:21
    // @abimethod({ allowActions: 'NoOp', onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/leak_swap/contract.algo.ts:5
    // export class LeakSwap extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txnas Accounts
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    // smart_contracts/leak_swap/contract.algo.ts:21
    // @abimethod({ allowActions: 'NoOp', onCreate: 'require' })
    callsub createApplication
    intc_1 // 1
    return


// smart_contracts/leak_swap/contract.algo.ts::LeakSwap.createApplication(aliXternalPK: bytes, xinAlgoAddr: bytes, xinXternalPK: bytes, t0: uint64, t1: uint64) -> void:
createApplication:
    // smart_contracts/leak_swap/contract.algo.ts:21-28
    // @abimethod({ allowActions: 'NoOp', onCreate: 'require' })
    // public createApplication(
    //   aliXternalPK: bytes,
    //   xinAlgoAddr: Account,
    //   xinXternalPK: bytes,
    //   t0: uint64,
    //   t1: uint64
    // ): void {
    proto 5 0
    // smart_contracts/leak_swap/contract.algo.ts:7
    // public aliAlgoAddr = GlobalState<Account>()
    bytec_0 // "aliAlgoAddr"
    // smart_contracts/leak_swap/contract.algo.ts:30
    // this.aliAlgoAddr.value = Global.creatorAddress
    global CreatorAddress
    app_global_put
    // smart_contracts/leak_swap/contract.algo.ts:10
    // public aliXternalPK = GlobalState<bytes>()
    bytec 5 // "aliXternalPK"
    // smart_contracts/leak_swap/contract.algo.ts:31
    // this.aliXternalPK.value = aliXternalPK
    frame_dig -5
    app_global_put
    // smart_contracts/leak_swap/contract.algo.ts:8
    // public xinAlgoAddr = GlobalState<Account>()
    bytec 4 // "xinAlgoAddr"
    // smart_contracts/leak_swap/contract.algo.ts:33
    // this.xinAlgoAddr.value = xinAlgoAddr
    frame_dig -4
    app_global_put
    // smart_contracts/leak_swap/contract.algo.ts:11
    // public xinXternalPK = GlobalState<bytes>()
    bytec 6 // "xinXternalPK"
    // smart_contracts/leak_swap/contract.algo.ts:34
    // this.xinXternalPK.value = xinXternalPK
    frame_dig -3
    app_global_put
    // smart_contracts/leak_swap/contract.algo.ts:13
    // public t0 = GlobalState<uint64>()
    bytec_2 // "t0"
    // smart_contracts/leak_swap/contract.algo.ts:36
    // this.t0.value = t0
    frame_dig -2
    app_global_put
    // smart_contracts/leak_swap/contract.algo.ts:14
    // public t1 = GlobalState<uint64>()
    bytec_3 // "t1"
    // smart_contracts/leak_swap/contract.algo.ts:37
    // this.t1.value = t1
    frame_dig -1
    app_global_put
    // smart_contracts/leak_swap/contract.algo.ts:39
    // assert(t1 > t0, 't1 must be greater than t0')
    frame_dig -1
    frame_dig -2
    >
    assert // t1 must be greater than t0
    // smart_contracts/leak_swap/contract.algo.ts:40
    // assert(t0 > Global.latestTimestamp, 't0 must be in the future')
    frame_dig -2
    global LatestTimestamp
    >
    assert // t0 must be in the future
    // smart_contracts/leak_swap/contract.algo.ts:41
    // assert(t1 > Global.latestTimestamp, 't1 must be in the future')
    frame_dig -1
    global LatestTimestamp
    >
    assert // t1 must be in the future
    retsub


// smart_contracts/leak_swap/contract.algo.ts::LeakSwap.disburseFunds(recipient: bytes) -> void:
disburseFunds:
    // smart_contracts/leak_swap/contract.algo.ts:44
    // private disburseFunds(recipient: Account): void {
    proto 1 0
    // smart_contracts/leak_swap/contract.algo.ts:45-51
    // itxn
    //   .payment({
    //     amount: 0,
    //     closeRemainderTo: recipient,
    //     receiver: recipient,
    //   })
    //   .submit()
    itxn_begin
    frame_dig -1
    itxn_field Receiver
    frame_dig -1
    itxn_field CloseRemainderTo
    // smart_contracts/leak_swap/contract.algo.ts:47
    // amount: 0,
    intc_0 // 0
    itxn_field Amount
    // smart_contracts/leak_swap/contract.algo.ts:45-50
    // itxn
    //   .payment({
    //     amount: 0,
    //     closeRemainderTo: recipient,
    //     receiver: recipient,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/leak_swap/contract.algo.ts:45-51
    // itxn
    //   .payment({
    //     amount: 0,
    //     closeRemainderTo: recipient,
    //     receiver: recipient,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/leak_swap/contract.algo.ts::LeakSwap.verifySignature(signature: bytes, xternalPK: bytes) -> void:
verifySignature:
    // smart_contracts/leak_swap/contract.algo.ts:56
    // public verifySignature(signature: bytes, xternalPK: bytes): void {
    proto 2 0
    // smart_contracts/leak_swap/contract.algo.ts:57
    // this.leakyVerifyEd25519(signature, xternalPK)
    frame_dig -2
    frame_dig -1
    callsub leakyVerifyEd25519
    retsub


// smart_contracts/leak_swap/contract.algo.ts::LeakSwap.leakyVerifyEd25519(signature: bytes, xternalPK: bytes) -> void:
leakyVerifyEd25519:
    // smart_contracts/leak_swap/contract.algo.ts:68
    // private leakyVerifyEd25519(signature: bytes, xternalPK: bytes): void {
    proto 2 0
    // smart_contracts/leak_swap/contract.algo.ts:70
    // extract(signature, 0, 32) === Bytes.fromHex('5866666666666666666666666666666666666666666666666666666666666666'),
    frame_dig -2
    extract 0 32
    pushbytes 0x5866666666666666666666666666666666666666666666666666666666666666
    ==
    // smart_contracts/leak_swap/contract.algo.ts:69-71
    // assert(
    //   extract(signature, 0, 32) === Bytes.fromHex('5866666666666666666666666666666666666666666666666666666666666666'),
    //   'R-point encoding not 0x58666... . Signature R must be broken (=BASEPOINT) to allow the secret key to be leaked!')
    assert // R-point encoding not 0x58666... . Signature R must be broken (=BASEPOINT) to allow the secret key to be leaked!
    // smart_contracts/leak_swap/contract.algo.ts:72
    // assert(ed25519verifyBare(Global.currentApplicationAddress.bytes, signature, xternalPK), 'Signature verification failed!')
    global CurrentApplicationAddress
    frame_dig -2
    frame_dig -1
    ed25519verify_bare
    assert // Signature verification failed!
    retsub


// smart_contracts/leak_swap/contract.algo.ts::LeakSwap.setReady() -> void:
setReady:
    // smart_contracts/leak_swap/contract.algo.ts:81
    // assertMatch(Txn, { sender: this.aliAlgoAddr.value }, 'Only Ali can set the contract to ready!')
    txn Sender
    // smart_contracts/leak_swap/contract.algo.ts:7
    // public aliAlgoAddr = GlobalState<Account>()
    intc_0 // 0
    bytec_0 // "aliAlgoAddr"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/leak_swap/contract.algo.ts:81
    // assertMatch(Txn, { sender: this.aliAlgoAddr.value }, 'Only Ali can set the contract to ready!')
    ==
    assert // Only Ali can set the contract to ready!
    // smart_contracts/leak_swap/contract.algo.ts:16
    // public aliReady = GlobalState({ initialValue: false })
    bytec_1 // "aliReady"
    // smart_contracts/leak_swap/contract.algo.ts:82
    // this.aliReady.value = true
    intc_1 // 1
    app_global_put
    retsub


// smart_contracts/leak_swap/contract.algo.ts::LeakSwap.getContractState() -> uint64:
getContractState:
    // smart_contracts/leak_swap/contract.algo.ts:90
    // if (Global.latestTimestamp > this.t1.value) {
    global LatestTimestamp
    // smart_contracts/leak_swap/contract.algo.ts:14
    // public t1 = GlobalState<uint64>()
    intc_0 // 0
    bytec_3 // "t1"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/leak_swap/contract.algo.ts:90
    // if (Global.latestTimestamp > this.t1.value) {
    >
    bz getContractState_after_if_else@2
    // smart_contracts/leak_swap/contract.algo.ts:91
    // return 3
    pushint 3 // 3
    retsub

getContractState_after_if_else@2:
    // smart_contracts/leak_swap/contract.algo.ts:93
    // if (Global.latestTimestamp > this.t0.value) {
    global LatestTimestamp
    // smart_contracts/leak_swap/contract.algo.ts:13
    // public t0 = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "t0"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/leak_swap/contract.algo.ts:93
    // if (Global.latestTimestamp > this.t0.value) {
    >
    bz getContractState_after_if_else@4
    // smart_contracts/leak_swap/contract.algo.ts:94
    // return 2
    pushint 2 // 2
    retsub

getContractState_after_if_else@4:
    // smart_contracts/leak_swap/contract.algo.ts:16
    // public aliReady = GlobalState({ initialValue: false })
    intc_0 // 0
    bytec_1 // "aliReady"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/leak_swap/contract.algo.ts:96
    // if (this.aliReady.value) {
    bz getContractState_after_if_else@6
    // smart_contracts/leak_swap/contract.algo.ts:97
    // return 1
    intc_1 // 1
    retsub

getContractState_after_if_else@6:
    // smart_contracts/leak_swap/contract.algo.ts:99
    // return 0
    intc_0 // 0
    retsub


// smart_contracts/leak_swap/contract.algo.ts::LeakSwap.leakyRefund(signature: bytes) -> void:
leakyRefund:
    // smart_contracts/leak_swap/contract.algo.ts:107
    // public leakyRefund(signature: bytes): void {
    proto 1 0
    // smart_contracts/leak_swap/contract.algo.ts:108
    // assertMatch(Txn, { sender: this.aliAlgoAddr.value }, 'Only Ali can do leaky refund!')
    txn Sender
    // smart_contracts/leak_swap/contract.algo.ts:7
    // public aliAlgoAddr = GlobalState<Account>()
    intc_0 // 0
    bytec_0 // "aliAlgoAddr"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/leak_swap/contract.algo.ts:108
    // assertMatch(Txn, { sender: this.aliAlgoAddr.value }, 'Only Ali can do leaky refund!')
    ==
    assert // Only Ali can do leaky refund!
    // smart_contracts/leak_swap/contract.algo.ts:109
    // assert(Global.latestTimestamp <= this.t0.value, 'Cannot refund after t0!')
    global LatestTimestamp
    // smart_contracts/leak_swap/contract.algo.ts:13
    // public t0 = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "t0"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/leak_swap/contract.algo.ts:109
    // assert(Global.latestTimestamp <= this.t0.value, 'Cannot refund after t0!')
    <=
    assert // Cannot refund after t0!
    // smart_contracts/leak_swap/contract.algo.ts:16
    // public aliReady = GlobalState({ initialValue: false })
    intc_0 // 0
    bytec_1 // "aliReady"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/leak_swap/contract.algo.ts:110
    // assert(!this.aliReady.value, 'Cannot refund after set ready!')
    !
    assert // Cannot refund after set ready!
    // smart_contracts/leak_swap/contract.algo.ts:10
    // public aliXternalPK = GlobalState<bytes>()
    intc_0 // 0
    bytec 5 // "aliXternalPK"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/leak_swap/contract.algo.ts:113
    // this.leakyVerifyEd25519(signature, this.aliXternalPK.value)
    frame_dig -1
    swap
    callsub leakyVerifyEd25519
    // smart_contracts/leak_swap/contract.algo.ts:7
    // public aliAlgoAddr = GlobalState<Account>()
    intc_0 // 0
    bytec_0 // "aliAlgoAddr"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/leak_swap/contract.algo.ts:115
    // this.disburseFunds(this.aliAlgoAddr.value)
    callsub disburseFunds
    retsub


// smart_contracts/leak_swap/contract.algo.ts::LeakSwap.leakyClaim(signature: bytes) -> void:
leakyClaim:
    // smart_contracts/leak_swap/contract.algo.ts:123
    // public leakyClaim(signature: bytes): void {
    proto 1 0

leakyClaim_while_top@6:
    pushint 2010 // 2010
    global OpcodeBudget
    >
    bz leakyClaim_after_while@11
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 7 // 0x068101
    itxn_field ApprovalProgram
    bytec 7 // 0x068101
    itxn_field ClearStateProgram
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    b leakyClaim_while_top@6

leakyClaim_after_while@11:
    // smart_contracts/leak_swap/contract.algo.ts:125
    // assertMatch(Txn, { sender: this.xinAlgoAddr.value }, 'Only Xin can do leaky claim!')
    txn Sender
    // smart_contracts/leak_swap/contract.algo.ts:8
    // public xinAlgoAddr = GlobalState<Account>()
    intc_0 // 0
    bytec 4 // "xinAlgoAddr"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/leak_swap/contract.algo.ts:125
    // assertMatch(Txn, { sender: this.xinAlgoAddr.value }, 'Only Xin can do leaky claim!')
    ==
    assert // Only Xin can do leaky claim!
    // smart_contracts/leak_swap/contract.algo.ts:126
    // assert(Global.latestTimestamp > this.t0.value || this.aliReady.value, 'Cannot claim: time must be past t0 OR Ali must have set ready!')
    global LatestTimestamp
    // smart_contracts/leak_swap/contract.algo.ts:13
    // public t0 = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "t0"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/leak_swap/contract.algo.ts:126
    // assert(Global.latestTimestamp > this.t0.value || this.aliReady.value, 'Cannot claim: time must be past t0 OR Ali must have set ready!')
    >
    bnz leakyClaim_bool_true@2
    // smart_contracts/leak_swap/contract.algo.ts:16
    // public aliReady = GlobalState({ initialValue: false })
    intc_0 // 0
    bytec_1 // "aliReady"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/leak_swap/contract.algo.ts:126
    // assert(Global.latestTimestamp > this.t0.value || this.aliReady.value, 'Cannot claim: time must be past t0 OR Ali must have set ready!')
    bz leakyClaim_bool_false@3

leakyClaim_bool_true@2:
    intc_1 // 1

leakyClaim_bool_merge@4:
    // smart_contracts/leak_swap/contract.algo.ts:126
    // assert(Global.latestTimestamp > this.t0.value || this.aliReady.value, 'Cannot claim: time must be past t0 OR Ali must have set ready!')
    assert // Cannot claim: time must be past t0 OR Ali must have set ready!
    // smart_contracts/leak_swap/contract.algo.ts:127
    // assert(Global.latestTimestamp < this.t1.value, 'Cannot claim after t1!')
    global LatestTimestamp
    // smart_contracts/leak_swap/contract.algo.ts:14
    // public t1 = GlobalState<uint64>()
    intc_0 // 0
    bytec_3 // "t1"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/leak_swap/contract.algo.ts:127
    // assert(Global.latestTimestamp < this.t1.value, 'Cannot claim after t1!')
    <
    assert // Cannot claim after t1!
    // smart_contracts/leak_swap/contract.algo.ts:11
    // public xinXternalPK = GlobalState<bytes>()
    intc_0 // 0
    bytec 6 // "xinXternalPK"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/leak_swap/contract.algo.ts:130
    // this.leakyVerifyEd25519(signature, this.xinXternalPK.value)
    frame_dig -1
    swap
    callsub leakyVerifyEd25519
    // smart_contracts/leak_swap/contract.algo.ts:8
    // public xinAlgoAddr = GlobalState<Account>()
    intc_0 // 0
    bytec 4 // "xinAlgoAddr"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/leak_swap/contract.algo.ts:132
    // this.disburseFunds(this.xinAlgoAddr.value)
    callsub disburseFunds
    retsub

leakyClaim_bool_false@3:
    intc_0 // 0
    b leakyClaim_bool_merge@4


// smart_contracts/leak_swap/contract.algo.ts::LeakSwap.punishRefund() -> void:
punishRefund:
    // smart_contracts/leak_swap/contract.algo.ts:141
    // assertMatch(Txn, { sender: this.aliAlgoAddr.value }, 'Only Ali can do punish refund!')
    txn Sender
    // smart_contracts/leak_swap/contract.algo.ts:7
    // public aliAlgoAddr = GlobalState<Account>()
    intc_0 // 0
    bytec_0 // "aliAlgoAddr"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/leak_swap/contract.algo.ts:141
    // assertMatch(Txn, { sender: this.aliAlgoAddr.value }, 'Only Ali can do punish refund!')
    ==
    assert // Only Ali can do punish refund!
    // smart_contracts/leak_swap/contract.algo.ts:142
    // assert(Global.latestTimestamp >= this.t1.value, 'Cannot punish refund before t1!')
    global LatestTimestamp
    // smart_contracts/leak_swap/contract.algo.ts:14
    // public t1 = GlobalState<uint64>()
    intc_0 // 0
    bytec_3 // "t1"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/leak_swap/contract.algo.ts:142
    // assert(Global.latestTimestamp >= this.t1.value, 'Cannot punish refund before t1!')
    >=
    assert // Cannot punish refund before t1!
    // smart_contracts/leak_swap/contract.algo.ts:7
    // public aliAlgoAddr = GlobalState<Account>()
    intc_0 // 0
    bytec_0 // "aliAlgoAddr"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/leak_swap/contract.algo.ts:143
    // this.disburseFunds(this.aliAlgoAddr.value)
    callsub disburseFunds
    retsub
